// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FMUDATAEXCHANGE_ONESILFMU_H_
#define FLATBUFFERS_GENERATED_FMUDATAEXCHANGE_ONESILFMU_H_

#include "flatbuffers/flatbuffers.h"

namespace OneSilFMU {

struct FMU_Exchange_Data;
struct FMU_Exchange_DataBuilder;

struct Label_Init_Data;
struct Label_Init_DataBuilder;

struct Init_Payload;
struct Init_PayloadBuilder;

struct Label_Runtime_Data;
struct Label_Runtime_DataBuilder;

struct Set_Get_Payload;
struct Set_Get_PayloadBuilder;

struct DoStep_Payload;
struct DoStep_PayloadBuilder;

struct Terminate_Payload;
struct Terminate_PayloadBuilder;

struct Ack_Payload;
struct Ack_PayloadBuilder;

enum State {
  State_Initialize = 0,
  State_DoStep = 1,
  State_Get = 2,
  State_Terminate = 3,
  State_Acknowledge = 4,
  State_Set = 5,
  State_MIN = State_Initialize,
  State_MAX = State_Set
};

inline const State (&EnumValuesState())[6] {
  static const State values[] = {
    State_Initialize,
    State_DoStep,
    State_Get,
    State_Terminate,
    State_Acknowledge,
    State_Set
  };
  return values;
}

inline const char * const *EnumNamesState() {
  static const char * const names[7] = {
    "Initialize",
    "DoStep",
    "Get",
    "Terminate",
    "Acknowledge",
    "Set",
    nullptr
  };
  return names;
}

inline const char *EnumNameState(State e) {
  if (flatbuffers::IsOutRange(e, State_Initialize, State_Set)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesState()[index];
}

enum Payload_Data {
  Payload_Data_NONE = 0,
  Payload_Data_Init_Payload = 1,
  Payload_Data_Set_Get_Payload = 2,
  Payload_Data_DoStep_Payload = 3,
  Payload_Data_Terminate_Payload = 4,
  Payload_Data_Ack_Payload = 5,
  Payload_Data_MIN = Payload_Data_NONE,
  Payload_Data_MAX = Payload_Data_Ack_Payload
};

inline const Payload_Data (&EnumValuesPayload_Data())[6] {
  static const Payload_Data values[] = {
    Payload_Data_NONE,
    Payload_Data_Init_Payload,
    Payload_Data_Set_Get_Payload,
    Payload_Data_DoStep_Payload,
    Payload_Data_Terminate_Payload,
    Payload_Data_Ack_Payload
  };
  return values;
}

inline const char * const *EnumNamesPayload_Data() {
  static const char * const names[7] = {
    "NONE",
    "Init_Payload",
    "Set_Get_Payload",
    "DoStep_Payload",
    "Terminate_Payload",
    "Ack_Payload",
    nullptr
  };
  return names;
}

inline const char *EnumNamePayload_Data(Payload_Data e) {
  if (flatbuffers::IsOutRange(e, Payload_Data_NONE, Payload_Data_Ack_Payload)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPayload_Data()[index];
}

template<typename T> struct Payload_DataTraits {
  static const Payload_Data enum_value = Payload_Data_NONE;
};

template<> struct Payload_DataTraits<OneSilFMU::Init_Payload> {
  static const Payload_Data enum_value = Payload_Data_Init_Payload;
};

template<> struct Payload_DataTraits<OneSilFMU::Set_Get_Payload> {
  static const Payload_Data enum_value = Payload_Data_Set_Get_Payload;
};

template<> struct Payload_DataTraits<OneSilFMU::DoStep_Payload> {
  static const Payload_Data enum_value = Payload_Data_DoStep_Payload;
};

template<> struct Payload_DataTraits<OneSilFMU::Terminate_Payload> {
  static const Payload_Data enum_value = Payload_Data_Terminate_Payload;
};

template<> struct Payload_DataTraits<OneSilFMU::Ack_Payload> {
  static const Payload_Data enum_value = Payload_Data_Ack_Payload;
};

bool VerifyPayload_Data(flatbuffers::Verifier &verifier, const void *obj, Payload_Data type);
bool VerifyPayload_DataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum CasualityType {
  CasualityType_INPUT_CAUSALITY = 0,
  CasualityType_OUTPUT_CAUSALITY = 1,
  CasualityType_PARAMETER_CAUSALITY = 2,
  CasualityType_MIN = CasualityType_INPUT_CAUSALITY,
  CasualityType_MAX = CasualityType_PARAMETER_CAUSALITY
};

inline const CasualityType (&EnumValuesCasualityType())[3] {
  static const CasualityType values[] = {
    CasualityType_INPUT_CAUSALITY,
    CasualityType_OUTPUT_CAUSALITY,
    CasualityType_PARAMETER_CAUSALITY
  };
  return values;
}

inline const char * const *EnumNamesCasualityType() {
  static const char * const names[4] = {
    "INPUT_CAUSALITY",
    "OUTPUT_CAUSALITY",
    "PARAMETER_CAUSALITY",
    nullptr
  };
  return names;
}

inline const char *EnumNameCasualityType(CasualityType e) {
  if (flatbuffers::IsOutRange(e, CasualityType_INPUT_CAUSALITY, CasualityType_PARAMETER_CAUSALITY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCasualityType()[index];
}

enum DeclaredDataType {
  DeclaredDataType_NONE = 0,
  DeclaredDataType_SIGNED_CHAR = 1,
  DeclaredDataType_SIGNED_SHORT = 2,
  DeclaredDataType_SIGNED_INT = 3,
  DeclaredDataType_UNSIGNED_CHAR = 4,
  DeclaredDataType_UNSIGNED_SHORT = 5,
  DeclaredDataType_UNSIGNED_INT = 6,
  DeclaredDataType_FLOAT32 = 7,
  DeclaredDataType_FLOAT64 = 8,
  DeclaredDataType_BOOLEAN = 9,
  DeclaredDataType_STRING = 10,
  DeclaredDataType_ENUMERATION = 11,
  DeclaredDataType_BINARY = 12,
  DeclaredDataType_MIN = DeclaredDataType_NONE,
  DeclaredDataType_MAX = DeclaredDataType_BINARY
};

inline const DeclaredDataType (&EnumValuesDeclaredDataType())[13] {
  static const DeclaredDataType values[] = {
    DeclaredDataType_NONE,
    DeclaredDataType_SIGNED_CHAR,
    DeclaredDataType_SIGNED_SHORT,
    DeclaredDataType_SIGNED_INT,
    DeclaredDataType_UNSIGNED_CHAR,
    DeclaredDataType_UNSIGNED_SHORT,
    DeclaredDataType_UNSIGNED_INT,
    DeclaredDataType_FLOAT32,
    DeclaredDataType_FLOAT64,
    DeclaredDataType_BOOLEAN,
    DeclaredDataType_STRING,
    DeclaredDataType_ENUMERATION,
    DeclaredDataType_BINARY
  };
  return values;
}

inline const char * const *EnumNamesDeclaredDataType() {
  static const char * const names[14] = {
    "NONE",
    "SIGNED_CHAR",
    "SIGNED_SHORT",
    "SIGNED_INT",
    "UNSIGNED_CHAR",
    "UNSIGNED_SHORT",
    "UNSIGNED_INT",
    "FLOAT32",
    "FLOAT64",
    "BOOLEAN",
    "STRING",
    "ENUMERATION",
    "BINARY",
    nullptr
  };
  return names;
}

inline const char *EnumNameDeclaredDataType(DeclaredDataType e) {
  if (flatbuffers::IsOutRange(e, DeclaredDataType_NONE, DeclaredDataType_BINARY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDeclaredDataType()[index];
}

enum ScalarVariableDataType {
  ScalarVariableDataType_FMI2_INTEGER = 0,
  ScalarVariableDataType_FMI2_REAL = 1,
  ScalarVariableDataType_FMI2_STRING = 2,
  ScalarVariableDataType_FMI2_BOOLEAN = 3,
  ScalarVariableDataType_MIN = ScalarVariableDataType_FMI2_INTEGER,
  ScalarVariableDataType_MAX = ScalarVariableDataType_FMI2_BOOLEAN
};

inline const ScalarVariableDataType (&EnumValuesScalarVariableDataType())[4] {
  static const ScalarVariableDataType values[] = {
    ScalarVariableDataType_FMI2_INTEGER,
    ScalarVariableDataType_FMI2_REAL,
    ScalarVariableDataType_FMI2_STRING,
    ScalarVariableDataType_FMI2_BOOLEAN
  };
  return values;
}

inline const char * const *EnumNamesScalarVariableDataType() {
  static const char * const names[5] = {
    "FMI2_INTEGER",
    "FMI2_REAL",
    "FMI2_STRING",
    "FMI2_BOOLEAN",
    nullptr
  };
  return names;
}

inline const char *EnumNameScalarVariableDataType(ScalarVariableDataType e) {
  if (flatbuffers::IsOutRange(e, ScalarVariableDataType_FMI2_INTEGER, ScalarVariableDataType_FMI2_BOOLEAN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesScalarVariableDataType()[index];
}

enum Status {
  Status_E_OK = 0,
  Status_E_ERROR = 1,
  Status_MIN = Status_E_OK,
  Status_MAX = Status_E_ERROR
};

inline const Status (&EnumValuesStatus())[2] {
  static const Status values[] = {
    Status_E_OK,
    Status_E_ERROR
  };
  return values;
}

inline const char * const *EnumNamesStatus() {
  static const char * const names[3] = {
    "E_OK",
    "E_ERROR",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatus(Status e) {
  if (flatbuffers::IsOutRange(e, Status_E_OK, Status_E_ERROR)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatus()[index];
}

struct FMU_Exchange_Data FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FMU_Exchange_DataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_STATE = 6,
    VT_PAYLOAD_TYPE = 8,
    VT_PAYLOAD = 10
  };
  float version() const {
    return GetField<float>(VT_VERSION, 1.0f);
  }
  OneSilFMU::State state() const {
    return static_cast<OneSilFMU::State>(GetField<int8_t>(VT_STATE, 0));
  }
  OneSilFMU::Payload_Data payload_type() const {
    return static_cast<OneSilFMU::Payload_Data>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const OneSilFMU::Init_Payload *payload_as_Init_Payload() const {
    return payload_type() == OneSilFMU::Payload_Data_Init_Payload ? static_cast<const OneSilFMU::Init_Payload *>(payload()) : nullptr;
  }
  const OneSilFMU::Set_Get_Payload *payload_as_Set_Get_Payload() const {
    return payload_type() == OneSilFMU::Payload_Data_Set_Get_Payload ? static_cast<const OneSilFMU::Set_Get_Payload *>(payload()) : nullptr;
  }
  const OneSilFMU::DoStep_Payload *payload_as_DoStep_Payload() const {
    return payload_type() == OneSilFMU::Payload_Data_DoStep_Payload ? static_cast<const OneSilFMU::DoStep_Payload *>(payload()) : nullptr;
  }
  const OneSilFMU::Terminate_Payload *payload_as_Terminate_Payload() const {
    return payload_type() == OneSilFMU::Payload_Data_Terminate_Payload ? static_cast<const OneSilFMU::Terminate_Payload *>(payload()) : nullptr;
  }
  const OneSilFMU::Ack_Payload *payload_as_Ack_Payload() const {
    return payload_type() == OneSilFMU::Payload_Data_Ack_Payload ? static_cast<const OneSilFMU::Ack_Payload *>(payload()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VERSION) &&
           VerifyField<int8_t>(verifier, VT_STATE) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyPayload_Data(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const OneSilFMU::Init_Payload *FMU_Exchange_Data::payload_as<OneSilFMU::Init_Payload>() const {
  return payload_as_Init_Payload();
}

template<> inline const OneSilFMU::Set_Get_Payload *FMU_Exchange_Data::payload_as<OneSilFMU::Set_Get_Payload>() const {
  return payload_as_Set_Get_Payload();
}

template<> inline const OneSilFMU::DoStep_Payload *FMU_Exchange_Data::payload_as<OneSilFMU::DoStep_Payload>() const {
  return payload_as_DoStep_Payload();
}

template<> inline const OneSilFMU::Terminate_Payload *FMU_Exchange_Data::payload_as<OneSilFMU::Terminate_Payload>() const {
  return payload_as_Terminate_Payload();
}

template<> inline const OneSilFMU::Ack_Payload *FMU_Exchange_Data::payload_as<OneSilFMU::Ack_Payload>() const {
  return payload_as_Ack_Payload();
}

struct FMU_Exchange_DataBuilder {
  typedef FMU_Exchange_Data Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(float version) {
    fbb_.AddElement<float>(FMU_Exchange_Data::VT_VERSION, version, 1.0f);
  }
  void add_state(OneSilFMU::State state) {
    fbb_.AddElement<int8_t>(FMU_Exchange_Data::VT_STATE, static_cast<int8_t>(state), 0);
  }
  void add_payload_type(OneSilFMU::Payload_Data payload_type) {
    fbb_.AddElement<uint8_t>(FMU_Exchange_Data::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(FMU_Exchange_Data::VT_PAYLOAD, payload);
  }
  explicit FMU_Exchange_DataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FMU_Exchange_DataBuilder &operator=(const FMU_Exchange_DataBuilder &);
  flatbuffers::Offset<FMU_Exchange_Data> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FMU_Exchange_Data>(end);
    return o;
  }
};

inline flatbuffers::Offset<FMU_Exchange_Data> CreateFMU_Exchange_Data(
    flatbuffers::FlatBufferBuilder &_fbb,
    float version = 1.0f,
    OneSilFMU::State state = OneSilFMU::State_Initialize,
    OneSilFMU::Payload_Data payload_type = OneSilFMU::Payload_Data_NONE,
    flatbuffers::Offset<void> payload = 0) {
  FMU_Exchange_DataBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_version(version);
  builder_.add_payload_type(payload_type);
  builder_.add_state(state);
  return builder_.Finish();
}

struct Label_Init_Data FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Label_Init_DataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_CASUALITY = 6,
    VT_NAME = 8,
    VT_VARIABILITY = 10,
    VT_SIZE = 12,
    VT_VALUEREFERENCE = 14,
    VT_FMIDATATTYPE = 16,
    VT_DECLAREDTYPE = 18,
    VT_APPLY_QUANTIZATION = 20,
    VT_FACTOR = 22,
    VT_OFFSET = 24
  };
  int32_t address() const {
    return GetField<int32_t>(VT_ADDRESS, 0);
  }
  OneSilFMU::CasualityType casuality() const {
    return static_cast<OneSilFMU::CasualityType>(GetField<int8_t>(VT_CASUALITY, 0));
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *variability() const {
    return GetPointer<const flatbuffers::String *>(VT_VARIABILITY);
  }
  int32_t size() const {
    return GetField<int32_t>(VT_SIZE, 0);
  }
  int32_t valuereference() const {
    return GetField<int32_t>(VT_VALUEREFERENCE, 0);
  }
  OneSilFMU::ScalarVariableDataType fmidatattype() const {
    return static_cast<OneSilFMU::ScalarVariableDataType>(GetField<int8_t>(VT_FMIDATATTYPE, 0));
  }
  OneSilFMU::DeclaredDataType declaredtype() const {
    return static_cast<OneSilFMU::DeclaredDataType>(GetField<int8_t>(VT_DECLAREDTYPE, 0));
  }
  bool apply_quantization() const {
    return GetField<uint8_t>(VT_APPLY_QUANTIZATION, 0) != 0;
  }
  float factor() const {
    return GetField<float>(VT_FACTOR, 0.0f);
  }
  float offset() const {
    return GetField<float>(VT_OFFSET, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ADDRESS) &&
           VerifyField<int8_t>(verifier, VT_CASUALITY) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VARIABILITY) &&
           verifier.VerifyString(variability()) &&
           VerifyField<int32_t>(verifier, VT_SIZE) &&
           VerifyField<int32_t>(verifier, VT_VALUEREFERENCE) &&
           VerifyField<int8_t>(verifier, VT_FMIDATATTYPE) &&
           VerifyField<int8_t>(verifier, VT_DECLAREDTYPE) &&
           VerifyField<uint8_t>(verifier, VT_APPLY_QUANTIZATION) &&
           VerifyField<float>(verifier, VT_FACTOR) &&
           VerifyField<float>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
};

struct Label_Init_DataBuilder {
  typedef Label_Init_Data Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(int32_t address) {
    fbb_.AddElement<int32_t>(Label_Init_Data::VT_ADDRESS, address, 0);
  }
  void add_casuality(OneSilFMU::CasualityType casuality) {
    fbb_.AddElement<int8_t>(Label_Init_Data::VT_CASUALITY, static_cast<int8_t>(casuality), 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Label_Init_Data::VT_NAME, name);
  }
  void add_variability(flatbuffers::Offset<flatbuffers::String> variability) {
    fbb_.AddOffset(Label_Init_Data::VT_VARIABILITY, variability);
  }
  void add_size(int32_t size) {
    fbb_.AddElement<int32_t>(Label_Init_Data::VT_SIZE, size, 0);
  }
  void add_valuereference(int32_t valuereference) {
    fbb_.AddElement<int32_t>(Label_Init_Data::VT_VALUEREFERENCE, valuereference, 0);
  }
  void add_fmidatattype(OneSilFMU::ScalarVariableDataType fmidatattype) {
    fbb_.AddElement<int8_t>(Label_Init_Data::VT_FMIDATATTYPE, static_cast<int8_t>(fmidatattype), 0);
  }
  void add_declaredtype(OneSilFMU::DeclaredDataType declaredtype) {
    fbb_.AddElement<int8_t>(Label_Init_Data::VT_DECLAREDTYPE, static_cast<int8_t>(declaredtype), 0);
  }
  void add_apply_quantization(bool apply_quantization) {
    fbb_.AddElement<uint8_t>(Label_Init_Data::VT_APPLY_QUANTIZATION, static_cast<uint8_t>(apply_quantization), 0);
  }
  void add_factor(float factor) {
    fbb_.AddElement<float>(Label_Init_Data::VT_FACTOR, factor, 0.0f);
  }
  void add_offset(float offset) {
    fbb_.AddElement<float>(Label_Init_Data::VT_OFFSET, offset, 0.0f);
  }
  explicit Label_Init_DataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Label_Init_DataBuilder &operator=(const Label_Init_DataBuilder &);
  flatbuffers::Offset<Label_Init_Data> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Label_Init_Data>(end);
    return o;
  }
};

inline flatbuffers::Offset<Label_Init_Data> CreateLabel_Init_Data(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t address = 0,
    OneSilFMU::CasualityType casuality = OneSilFMU::CasualityType_INPUT_CAUSALITY,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> variability = 0,
    int32_t size = 0,
    int32_t valuereference = 0,
    OneSilFMU::ScalarVariableDataType fmidatattype = OneSilFMU::ScalarVariableDataType_FMI2_INTEGER,
    OneSilFMU::DeclaredDataType declaredtype = OneSilFMU::DeclaredDataType_NONE,
    bool apply_quantization = false,
    float factor = 0.0f,
    float offset = 0.0f) {
  Label_Init_DataBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_factor(factor);
  builder_.add_valuereference(valuereference);
  builder_.add_size(size);
  builder_.add_variability(variability);
  builder_.add_name(name);
  builder_.add_address(address);
  builder_.add_apply_quantization(apply_quantization);
  builder_.add_declaredtype(declaredtype);
  builder_.add_fmidatattype(fmidatattype);
  builder_.add_casuality(casuality);
  return builder_.Finish();
}

inline flatbuffers::Offset<Label_Init_Data> CreateLabel_Init_DataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t address = 0,
    OneSilFMU::CasualityType casuality = OneSilFMU::CasualityType_INPUT_CAUSALITY,
    const char *name = nullptr,
    const char *variability = nullptr,
    int32_t size = 0,
    int32_t valuereference = 0,
    OneSilFMU::ScalarVariableDataType fmidatattype = OneSilFMU::ScalarVariableDataType_FMI2_INTEGER,
    OneSilFMU::DeclaredDataType declaredtype = OneSilFMU::DeclaredDataType_NONE,
    bool apply_quantization = false,
    float factor = 0.0f,
    float offset = 0.0f) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto variability__ = variability ? _fbb.CreateString(variability) : 0;
  return OneSilFMU::CreateLabel_Init_Data(
      _fbb,
      address,
      casuality,
      name__,
      variability__,
      size,
      valuereference,
      fmidatattype,
      declaredtype,
      apply_quantization,
      factor,
      offset);
}

struct Init_Payload FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Init_PayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LABEL_INIT_ARRAY = 4,
    VT_CURRENTFMURESOURCEFOLDERPATH = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<OneSilFMU::Label_Init_Data>> *label_init_array() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OneSilFMU::Label_Init_Data>> *>(VT_LABEL_INIT_ARRAY);
  }
  const flatbuffers::String *currentFMUResourceFolderPath() const {
    return GetPointer<const flatbuffers::String *>(VT_CURRENTFMURESOURCEFOLDERPATH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LABEL_INIT_ARRAY) &&
           verifier.VerifyVector(label_init_array()) &&
           verifier.VerifyVectorOfTables(label_init_array()) &&
           VerifyOffset(verifier, VT_CURRENTFMURESOURCEFOLDERPATH) &&
           verifier.VerifyString(currentFMUResourceFolderPath()) &&
           verifier.EndTable();
  }
};

struct Init_PayloadBuilder {
  typedef Init_Payload Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_label_init_array(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OneSilFMU::Label_Init_Data>>> label_init_array) {
    fbb_.AddOffset(Init_Payload::VT_LABEL_INIT_ARRAY, label_init_array);
  }
  void add_currentFMUResourceFolderPath(flatbuffers::Offset<flatbuffers::String> currentFMUResourceFolderPath) {
    fbb_.AddOffset(Init_Payload::VT_CURRENTFMURESOURCEFOLDERPATH, currentFMUResourceFolderPath);
  }
  explicit Init_PayloadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Init_PayloadBuilder &operator=(const Init_PayloadBuilder &);
  flatbuffers::Offset<Init_Payload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Init_Payload>(end);
    return o;
  }
};

inline flatbuffers::Offset<Init_Payload> CreateInit_Payload(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OneSilFMU::Label_Init_Data>>> label_init_array = 0,
    flatbuffers::Offset<flatbuffers::String> currentFMUResourceFolderPath = 0) {
  Init_PayloadBuilder builder_(_fbb);
  builder_.add_currentFMUResourceFolderPath(currentFMUResourceFolderPath);
  builder_.add_label_init_array(label_init_array);
  return builder_.Finish();
}

inline flatbuffers::Offset<Init_Payload> CreateInit_PayloadDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<OneSilFMU::Label_Init_Data>> *label_init_array = nullptr,
    const char *currentFMUResourceFolderPath = nullptr) {
  auto label_init_array__ = label_init_array ? _fbb.CreateVector<flatbuffers::Offset<OneSilFMU::Label_Init_Data>>(*label_init_array) : 0;
  auto currentFMUResourceFolderPath__ = currentFMUResourceFolderPath ? _fbb.CreateString(currentFMUResourceFolderPath) : 0;
  return OneSilFMU::CreateInit_Payload(
      _fbb,
      label_init_array__,
      currentFMUResourceFolderPath__);
}

struct Label_Runtime_Data FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Label_Runtime_DataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FMIDATATTYPE = 4,
    VT_VALUEREFERENCE = 6,
    VT_VALUE = 8,
    VT_LENGTH = 10
  };
  OneSilFMU::ScalarVariableDataType fmidatattype() const {
    return static_cast<OneSilFMU::ScalarVariableDataType>(GetField<int8_t>(VT_FMIDATATTYPE, 0));
  }
  int32_t valueReference() const {
    return GetField<int32_t>(VT_VALUEREFERENCE, 0);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  int32_t length() const {
    return GetField<int32_t>(VT_LENGTH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FMIDATATTYPE) &&
           VerifyField<int32_t>(verifier, VT_VALUEREFERENCE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           VerifyField<int32_t>(verifier, VT_LENGTH) &&
           verifier.EndTable();
  }
};

struct Label_Runtime_DataBuilder {
  typedef Label_Runtime_Data Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fmidatattype(OneSilFMU::ScalarVariableDataType fmidatattype) {
    fbb_.AddElement<int8_t>(Label_Runtime_Data::VT_FMIDATATTYPE, static_cast<int8_t>(fmidatattype), 0);
  }
  void add_valueReference(int32_t valueReference) {
    fbb_.AddElement<int32_t>(Label_Runtime_Data::VT_VALUEREFERENCE, valueReference, 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(Label_Runtime_Data::VT_VALUE, value);
  }
  void add_length(int32_t length) {
    fbb_.AddElement<int32_t>(Label_Runtime_Data::VT_LENGTH, length, 0);
  }
  explicit Label_Runtime_DataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Label_Runtime_DataBuilder &operator=(const Label_Runtime_DataBuilder &);
  flatbuffers::Offset<Label_Runtime_Data> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Label_Runtime_Data>(end);
    return o;
  }
};

inline flatbuffers::Offset<Label_Runtime_Data> CreateLabel_Runtime_Data(
    flatbuffers::FlatBufferBuilder &_fbb,
    OneSilFMU::ScalarVariableDataType fmidatattype = OneSilFMU::ScalarVariableDataType_FMI2_INTEGER,
    int32_t valueReference = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0,
    int32_t length = 0) {
  Label_Runtime_DataBuilder builder_(_fbb);
  builder_.add_length(length);
  builder_.add_value(value);
  builder_.add_valueReference(valueReference);
  builder_.add_fmidatattype(fmidatattype);
  return builder_.Finish();
}

inline flatbuffers::Offset<Label_Runtime_Data> CreateLabel_Runtime_DataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    OneSilFMU::ScalarVariableDataType fmidatattype = OneSilFMU::ScalarVariableDataType_FMI2_INTEGER,
    int32_t valueReference = 0,
    const std::vector<uint8_t> *value = nullptr,
    int32_t length = 0) {
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return OneSilFMU::CreateLabel_Runtime_Data(
      _fbb,
      fmidatattype,
      valueReference,
      value__,
      length);
}

struct Set_Get_Payload FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Set_Get_PayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LABELARRAY = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<OneSilFMU::Label_Runtime_Data>> *labelArray() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OneSilFMU::Label_Runtime_Data>> *>(VT_LABELARRAY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LABELARRAY) &&
           verifier.VerifyVector(labelArray()) &&
           verifier.VerifyVectorOfTables(labelArray()) &&
           verifier.EndTable();
  }
};

struct Set_Get_PayloadBuilder {
  typedef Set_Get_Payload Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_labelArray(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OneSilFMU::Label_Runtime_Data>>> labelArray) {
    fbb_.AddOffset(Set_Get_Payload::VT_LABELARRAY, labelArray);
  }
  explicit Set_Get_PayloadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Set_Get_PayloadBuilder &operator=(const Set_Get_PayloadBuilder &);
  flatbuffers::Offset<Set_Get_Payload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Set_Get_Payload>(end);
    return o;
  }
};

inline flatbuffers::Offset<Set_Get_Payload> CreateSet_Get_Payload(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OneSilFMU::Label_Runtime_Data>>> labelArray = 0) {
  Set_Get_PayloadBuilder builder_(_fbb);
  builder_.add_labelArray(labelArray);
  return builder_.Finish();
}

inline flatbuffers::Offset<Set_Get_Payload> CreateSet_Get_PayloadDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<OneSilFMU::Label_Runtime_Data>> *labelArray = nullptr) {
  auto labelArray__ = labelArray ? _fbb.CreateVector<flatbuffers::Offset<OneSilFMU::Label_Runtime_Data>>(*labelArray) : 0;
  return OneSilFMU::CreateSet_Get_Payload(
      _fbb,
      labelArray__);
}

struct DoStep_Payload FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DoStep_PayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LABELARRAY = 4,
    VT_COMMUNICATIONSTEPSIZE = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<OneSilFMU::Label_Runtime_Data>> *labelArray() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OneSilFMU::Label_Runtime_Data>> *>(VT_LABELARRAY);
  }
  float communicationStepSize() const {
    return GetField<float>(VT_COMMUNICATIONSTEPSIZE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LABELARRAY) &&
           verifier.VerifyVector(labelArray()) &&
           verifier.VerifyVectorOfTables(labelArray()) &&
           VerifyField<float>(verifier, VT_COMMUNICATIONSTEPSIZE) &&
           verifier.EndTable();
  }
};

struct DoStep_PayloadBuilder {
  typedef DoStep_Payload Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_labelArray(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OneSilFMU::Label_Runtime_Data>>> labelArray) {
    fbb_.AddOffset(DoStep_Payload::VT_LABELARRAY, labelArray);
  }
  void add_communicationStepSize(float communicationStepSize) {
    fbb_.AddElement<float>(DoStep_Payload::VT_COMMUNICATIONSTEPSIZE, communicationStepSize, 0.0f);
  }
  explicit DoStep_PayloadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DoStep_PayloadBuilder &operator=(const DoStep_PayloadBuilder &);
  flatbuffers::Offset<DoStep_Payload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DoStep_Payload>(end);
    return o;
  }
};

inline flatbuffers::Offset<DoStep_Payload> CreateDoStep_Payload(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OneSilFMU::Label_Runtime_Data>>> labelArray = 0,
    float communicationStepSize = 0.0f) {
  DoStep_PayloadBuilder builder_(_fbb);
  builder_.add_communicationStepSize(communicationStepSize);
  builder_.add_labelArray(labelArray);
  return builder_.Finish();
}

inline flatbuffers::Offset<DoStep_Payload> CreateDoStep_PayloadDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<OneSilFMU::Label_Runtime_Data>> *labelArray = nullptr,
    float communicationStepSize = 0.0f) {
  auto labelArray__ = labelArray ? _fbb.CreateVector<flatbuffers::Offset<OneSilFMU::Label_Runtime_Data>>(*labelArray) : 0;
  return OneSilFMU::CreateDoStep_Payload(
      _fbb,
      labelArray__,
      communicationStepSize);
}

struct Terminate_Payload FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Terminate_PayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TERMINATE = 4
  };
  bool terminate() const {
    return GetField<uint8_t>(VT_TERMINATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TERMINATE) &&
           verifier.EndTable();
  }
};

struct Terminate_PayloadBuilder {
  typedef Terminate_Payload Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_terminate(bool terminate) {
    fbb_.AddElement<uint8_t>(Terminate_Payload::VT_TERMINATE, static_cast<uint8_t>(terminate), 0);
  }
  explicit Terminate_PayloadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Terminate_PayloadBuilder &operator=(const Terminate_PayloadBuilder &);
  flatbuffers::Offset<Terminate_Payload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Terminate_Payload>(end);
    return o;
  }
};

inline flatbuffers::Offset<Terminate_Payload> CreateTerminate_Payload(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool terminate = false) {
  Terminate_PayloadBuilder builder_(_fbb);
  builder_.add_terminate(terminate);
  return builder_.Finish();
}

struct Ack_Payload FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Ack_PayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_ERRORMSG = 6
  };
  OneSilFMU::Status status() const {
    return static_cast<OneSilFMU::Status>(GetField<int8_t>(VT_STATUS, 0));
  }
  const flatbuffers::String *errorMsg() const {
    return GetPointer<const flatbuffers::String *>(VT_ERRORMSG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_ERRORMSG) &&
           verifier.VerifyString(errorMsg()) &&
           verifier.EndTable();
  }
};

struct Ack_PayloadBuilder {
  typedef Ack_Payload Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(OneSilFMU::Status status) {
    fbb_.AddElement<int8_t>(Ack_Payload::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_errorMsg(flatbuffers::Offset<flatbuffers::String> errorMsg) {
    fbb_.AddOffset(Ack_Payload::VT_ERRORMSG, errorMsg);
  }
  explicit Ack_PayloadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Ack_PayloadBuilder &operator=(const Ack_PayloadBuilder &);
  flatbuffers::Offset<Ack_Payload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Ack_Payload>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ack_Payload> CreateAck_Payload(
    flatbuffers::FlatBufferBuilder &_fbb,
    OneSilFMU::Status status = OneSilFMU::Status_E_OK,
    flatbuffers::Offset<flatbuffers::String> errorMsg = 0) {
  Ack_PayloadBuilder builder_(_fbb);
  builder_.add_errorMsg(errorMsg);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<Ack_Payload> CreateAck_PayloadDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    OneSilFMU::Status status = OneSilFMU::Status_E_OK,
    const char *errorMsg = nullptr) {
  auto errorMsg__ = errorMsg ? _fbb.CreateString(errorMsg) : 0;
  return OneSilFMU::CreateAck_Payload(
      _fbb,
      status,
      errorMsg__);
}

inline bool VerifyPayload_Data(flatbuffers::Verifier &verifier, const void *obj, Payload_Data type) {
  switch (type) {
    case Payload_Data_NONE: {
      return true;
    }
    case Payload_Data_Init_Payload: {
      auto ptr = reinterpret_cast<const OneSilFMU::Init_Payload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_Data_Set_Get_Payload: {
      auto ptr = reinterpret_cast<const OneSilFMU::Set_Get_Payload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_Data_DoStep_Payload: {
      auto ptr = reinterpret_cast<const OneSilFMU::DoStep_Payload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_Data_Terminate_Payload: {
      auto ptr = reinterpret_cast<const OneSilFMU::Terminate_Payload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_Data_Ack_Payload: {
      auto ptr = reinterpret_cast<const OneSilFMU::Ack_Payload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPayload_DataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPayload_Data(
        verifier,  values->Get(i), types->GetEnum<Payload_Data>(i))) {
      return false;
    }
  }
  return true;
}

inline const OneSilFMU::FMU_Exchange_Data *GetFMU_Exchange_Data(const void *buf) {
  return flatbuffers::GetRoot<OneSilFMU::FMU_Exchange_Data>(buf);
}

inline const OneSilFMU::FMU_Exchange_Data *GetSizePrefixedFMU_Exchange_Data(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<OneSilFMU::FMU_Exchange_Data>(buf);
}

inline const char *FMU_Exchange_DataIdentifier() {
  return "FMUD";
}

inline bool FMU_Exchange_DataBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, FMU_Exchange_DataIdentifier());
}

inline bool VerifyFMU_Exchange_DataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<OneSilFMU::FMU_Exchange_Data>(FMU_Exchange_DataIdentifier());
}

inline bool VerifySizePrefixedFMU_Exchange_DataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<OneSilFMU::FMU_Exchange_Data>(FMU_Exchange_DataIdentifier());
}

inline const char *FMU_Exchange_DataExtension() {
  return "abcd";
}

inline void FinishFMU_Exchange_DataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<OneSilFMU::FMU_Exchange_Data> root) {
  fbb.Finish(root, FMU_Exchange_DataIdentifier());
}

inline void FinishSizePrefixedFMU_Exchange_DataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<OneSilFMU::FMU_Exchange_Data> root) {
  fbb.FinishSizePrefixed(root, FMU_Exchange_DataIdentifier());
}

}  // namespace OneSilFMU

#endif  // FLATBUFFERS_GENERATED_FMUDATAEXCHANGE_ONESILFMU_H_
